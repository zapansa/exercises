
/**
 * DO NOT EDIT THIS FILE
 */

//
#include <fstream>
#include <iostream>
#include <string>
#include <vector>


//
#include "BookStore.hpp"
#include "DoublyLinkedList.hpp"
#include "puhp-tests/PuhPTests.hpp"


//
using std::cout, std::cin, std::endl;
using std::string;
using std::vector;


//
using PuhPTests::Tests;
using PuhPTests::Test;
using PuhPTests::OutputCapture;


//
using
	CPSC131::BookStore::BookStore,
	CPSC131::BookStore::Book
	;


//	PROTO
void preventPrototypeTampering();
BookStore makeBookStore(bool empty = false);
std::vector<Book> makeBooks();
CPSC131::DoublyLinkedList::DoublyLinkedList<int> makeList();
bool checkIntegerListsEqual(const CPSC131::DoublyLinkedList::DoublyLinkedList<int>& list1, const CPSC131::DoublyLinkedList::DoublyLinkedList<int>& list2);
bool checkIntegerListContents(const CPSC131::DoublyLinkedList::DoublyLinkedList<int>& list, const std::vector<int>& v);
//
template<class T>
void printList(CPSC131::DoublyLinkedList::DoublyLinkedList<T>& list);
//
//
void testPrinting(Tests& tests);
void testBasicLists(Tests& tests);
void testListAssignment(Tests& tests);
void testListAccordion(Tests& tests);
void testListReverse(Tests& tests);
void testIterators(Tests& tests);
void testInsertPush(Tests& tests);
void testErase(Tests& tests);
void testAssign(Tests& tests);
void testPointerStealing(Tests& tests);
void testStockSales(Tests& tests);
void testMemoryLeaks(Tests& tests);


//
int main()
{
	//
	Tests tests(50);
	
	//
	std::vector<std::function<void(Tests&)>> fs = {
		testBasicLists,
		testListAssignment,
		testIterators,
		testInsertPush,
		testErase,
		testAssign,
		testPointerStealing,
		testListAccordion,
		testListReverse,
		testStockSales,
		testPrinting,
		testMemoryLeaks,
	};
	
	//
	for ( auto f : fs ) {
		f(tests);
	}
	
	//
	tests.setResultsFileName("results-cpp.json");
	tests.run();
	
	//
	cout << "Tests complete" << endl;
	
	return 0;
}

void preventPrototypeTampering()
{
	//
	typedef CPSC131::DoublyLinkedList::DoublyLinkedList<int> DLL;
	typedef DLL::Node Node;
	typedef DLL::Iterator Iterator;
	typedef CPSC131::BookStore::BookStore BookStore;
	typedef CPSC131::DoublyLinkedList::DoublyLinkedList<Book>::Iterator BookStoreIterator;
	typedef CPSC131::BookStore::Book Book;
	
	//	Iterators
	{
		Node* (Iterator::* a)(void);
		a = &Iterator::begin;
		a = &Iterator::end;
		a = &Iterator::getCursor;
		if (a) {}
	}
	
	//	Nodes
	{
		//
		void (Node::* a)(Node*);
		a = &Node::setPrev;
		a = &Node::setPrevious;
		a = &Node::setNext;
		if (a) {}
		
		//
		Node* (Node::* b)(void);
		b = &Node::getPrev;
		b = &Node::getPrevious;
		b = &Node::getNext;
		if (b) {}
		
		//
		void (Node::* c)(int);
		c = &Node::setElement;
		if (c) {}
		
		//
		int& (Node::* d)(void);
		d = &Node::getElement;
		if (d) {}
	}
	
	//	DLL Getters / Accessors
	{
		Node* (DLL::* a)(void) const;
		a = &DLL::head;
		a = &DLL::tail;
		if (a) {}
		
		Iterator (DLL::* b)(void) const;
		b = &DLL::begin;
		b = &DLL::end;
		b = &DLL::last;
		if (b) {}
		
		bool (DLL::* c)(void) const;
		c = &DLL::empty;
		if (c) {}
		
		size_t (DLL::* d)(void) const;
		d = &DLL::size;
		if (d) {}
	}
	
	//	DLL Setters / Mutators
	{
		void (DLL::* a)(size_t, const int&) = &DLL::assign;
		if (a) {}
		
		void (DLL::* b)(Iterator first, Iterator last) = &DLL::assign;
		if (b) {}
		
		void (DLL::* c)(void);
		c = &DLL::clear;
		c = &DLL::pop_front;
		c = &DLL::pop_back;
		c = &DLL::reverse;
		if (c) {}
		
		Iterator (DLL::* d)(Iterator, const int&);
		d = &DLL::insert_after;
		d = &DLL::push_after;
		if (d) {}
		
		Iterator (DLL::* e)(size_t pos, const int& value) = &DLL::insert_after;
		if (e) {}
		
		Iterator (DLL::* f)(Iterator pos) = &DLL::erase;
		if (f) {}
		
		void (DLL::* g)(const int& value) = &DLL::push_front;
		if (g) {}
		
		Iterator (DLL::* h)(const int& value) = &DLL::push_back;
		if (h) {}
		
		int& (DLL::* i)(void);
		i = &DLL::front;
		i = &DLL::back;
		if (i) {}
		
		int& (DLL::* j)(size_t);
		j = &DLL::at;
		if (j) {}
	}
	
	//	Book
	{
		//	Getters / Accessors
		{
			std::string (Book::* a)(void) const;
			a = &Book::getTitle;
			a = &Book::getAuthor;
			a = &Book::getIsbn;
			if (a) {}
			
			size_t (Book::* b)(void) const;
			b = &Book::getPriceCents;
			b = &Book::getStockAvailable;
			if (b) {}
		}
		
		//	Setters / Mutators
		{
			void (Book::* a)(int) = &Book::adjustStockAvailable;
			if (a) {}
		}
	}
	
	//	BookStore
	{
		//	Getters / Accessors
		{
			int (BookStore::* a)(void) const = &BookStore::getAccountBalance;
			if (a) {}
			
			Book& (BookStore::* b)(std::string) const = &BookStore::getBook;
			if (b) {}
			
			BookStoreIterator (BookStore::* c)(std::string) const;
			c = &BookStore::findBook;
			if (c) {}
			
			bool (BookStore::* d)(std::string) const;
			d = &BookStore::bookExists;
			if (d) {}
			
			size_t (BookStore::* e)(std::string) const;
			e = &BookStore::getBookStockAvailable;
			if (e) {}
			
			void (BookStore::* f)(void) const = &BookStore::printInventory;
			if (f) {}
		}
		
		//	Setters / Mutators
		{
			void (BookStore::* a)(int) = &BookStore::adjustAccountBalance;
			if (a) {}
			
			void (BookStore::* b)(const Book&) = &BookStore::purchaseInventory;
			if (b) {}
			
			void (BookStore::* c)(
				std::string title, std::string author, std::string isbn,
				size_t price_cents,
				size_t unit_count
			) = &BookStore::purchaseInventory;
			if (c) {}
			
			
			void (BookStore::* d)(std::string, size_t, size_t) = &BookStore::sellToCustomer;
			if (d) {}
			void (BookStore::* e)(Book&, size_t, size_t) = &BookStore::sellToCustomer;
			if (e) {}
		}
	}
}

//
BookStore makeBookStore(bool empty)
{
	//
	BookStore store;
	
	//
	auto books = makeBooks();
	size_t quantity = 50;
	for ( Book b : books ) {
		
		//
		if ( !empty ) {
			b.adjustStockAvailable(quantity);
			quantity--;
		}
		
		store.purchaseInventory(b);
	}
	
	return store;
}

//
std::vector<Book> makeBooks()
{
	//
	std::vector<Book> v = {
		Book("Brainwashing is a Cinch!", "James Maratta", "B001NDNB7C", 900),
		Book("Catflexing - A Catlover's Guide to Weight Training, Aerobics, and Stretching", "Stephanie Jackson", "0898159407", 550),
		Book("How to Enjoy Your Weeds", "Audrey Wynne Hatfield", "080693042X", 1200),
		Book("How to Teach Quantum Physics to Your Dog", "Chad Orzel", "1416572295", 2000),
		Book("How to Train Goldfish Using Dolphin Training Techniques", "C. Scott Johnson", "0533112923", 100)
	};
	
	return v;
}

//
CPSC131::DoublyLinkedList::DoublyLinkedList<int> makeList()
{
	//
	CPSC131::DoublyLinkedList::DoublyLinkedList<int> list;
	
	//
	for ( size_t i = 0; i < 20; i++ ) {
		int value = (i * 3) - 30;
		list.push_back(value);
	}
	
	return list;
}

//
bool checkIntegerListsEqual(CPSC131::DoublyLinkedList::DoublyLinkedList<int>& list1, CPSC131::DoublyLinkedList::DoublyLinkedList<int>& list2)
{
	//
	if ( list1.size() != list2.size() ) {
		return false;
	}
	
	//
	for ( size_t i = 0; i < list1.size(); i++ ) {
		if ( list1.at(i) != list2.at(i) ) {
			return false;
		}
	}
	
	return true;
}

//
bool checkIntegerListContents(const CPSC131::DoublyLinkedList::DoublyLinkedList<int>& list, const std::vector<int>& v)
{
	bool result = true;
	
	if ( list.size() != v.size() ) {
		result = false;
	}
	else {
		
		auto itr_list = list.begin();
		auto itr_vec = v.begin();
		while( itr_list != list.end() && itr_vec != v.end() )
		{
			auto value_list = *itr_list;
			auto value_vec = *itr_vec;
			
			if ( value_list != value_vec ) {
				result = false;
				break;
			}
			
			itr_list++;
			itr_vec++;
		}
	}
	
	return result;
}

//
template <class T>
void printList(CPSC131::DoublyLinkedList::DoublyLinkedList<T>& list)
{
	//
	auto node = list.head();
	size_t index = 0;
	
	//
	cout << "{";
	while (node != nullptr)
	{
		//
		if ( index > 0 ) {
			cout << ", ";
		}
		cout << index << ":" << node->getElement();
		
		//
		node = node->getNext();
		index++;
	}
	cout << "}" << endl;
}

//
void testPrinting(Tests& tests)
{
	//
	auto t = tests.createTest("Printing");
	
	//
	t->setFixedPointsPossible(2);
	t->setNormalizedPointsPossibleTarget(5);
	
	//
	t->assertNoException(
		[t]()
		{
			//
			auto store = makeBookStore();
			
			//
			OutputCapture cap;
			store.printInventory();
			cap.endCapture();
			
			//
			string expected = "*** Book Store Inventory ***\n"
				"\"Brainwashing is a Cinch!\", by James Maratta [B001NDNB7C] (50 in stock)\n"
				"\"Catflexing - A Catlover's Guide to Weight Training, Aerobics, and Stretching\", by Stephanie Jackson [0898159407] (49 in stock)\n"
				"\"How to Enjoy Your Weeds\", by Audrey Wynne Hatfield [080693042X] (48 in stock)\n"
				"\"How to Teach Quantum Physics to Your Dog\", by Chad Orzel [1416572295] (47 in stock)\n"
				"\"How to Train Goldfish Using Dolphin Training Techniques\", by C. Scott Johnson [0533112923] (46 in stock)\n"
				;
			
			//
			t->assertEqual(cap.getStdout(), expected, 1, "Basic store printout");
			
		}, 1, "Print tests"
	);
}

//
void testBasicLists(Tests& tests)
{
	//
	auto t = tests.createTest("List basics");
	
	//
	t->setFixedPointsPossible(13);
	t->setNormalizedPointsPossibleTarget(10);
	
	//
	t->assertNoException(
		[t]()
		{
			//
			{
				//
				auto list = makeList();
				
				//	Check some values
				t->assertEqual(
					list.at(0), static_cast<int>(-30),
					1, "Checking random access"
				);
				t->assertEqual(
					list.at(3), static_cast<int>(-21),
					1, "Checking random access"
				);
				t->assertEqual(
					list.at(16), static_cast<int>(18),
					1, "Checking random access"
				);
				
				//	Size
				t->assertEqual(
					list.size(), static_cast<size_t>(20),
					1, "Checking size"
				);
				
				//	Add a couple items at random access
				list.insert_after(7, 119);
				list.insert_after(13, 181);
				t->assertEqual(
					list.size(), static_cast<size_t>(22),
					1, "Checking size after arbitrary insertions"
				);
				t->assertEqual(
					list.at(8), static_cast<int>(119),
					1, "Checking arbitrary insertion"
				);
				t->assertEqual(
					list.at(14), static_cast<int>(181),
					1, "Checking arbitrary insertion"
				);
				
				//	Push back and push front
				list.push_front(1011);
				list.push_back(1012);
				t->assertEqual(
					list.size(), static_cast<size_t>(24),
					1, "Checking size after push front/back"
				);
				t->assertEqual(
					list.at(0), static_cast<int>(1011),
					1, "Checking value after push front"
				);
				t->assertEqual(
					list.at(list.size() - 1), static_cast<int>(1012),
					1, "Checking value after push back"
				);
				
				//	Check the front and back
				t->assertEqual(
					list.front(), static_cast<int>(1011),
					1, "Checking value at front()"
				);
				t->assertEqual(
					list.back(), static_cast<int>(1012),
					1, "Checking value at back()"
				);

			}
			
		}, 1, "Basic add/remove tests"
	);
}

//
void testListAssignment(Tests& tests)
{
	//
	auto t = tests.createTest("Assignment");
	
	//
	t->setFixedPointsPossible(10);
	t->setNormalizedPointsPossibleTarget(10);
	
	//
	t->assertNoException(
		[t]()
		{
			//
			{
				//
				CPSC131::DoublyLinkedList::DoublyLinkedList<int> list;
				list.push_front(19);
				list.push_front(12);
				list.push_front(-129878);
				list.push_front(228764364);
				list.push_front(119991111);
				list.push_front(0);
				list.push_front(1900000000);
				
				//	Test the assignment operator
				//	Reminder: using auto would invoke the copy CTOR instead
				CPSC131::DoublyLinkedList::DoublyLinkedList<int> list2;
				list2 = list;
				t->assertTrue(checkIntegerListsEqual(list, list2), 1, "Assignment operator should work");
				
				//	Check the copy CTOR (explicit)
				CPSC131::DoublyLinkedList::DoublyLinkedList<int> list3(list);
				t->assertTrue(checkIntegerListsEqual(list, list3), 1, "Copy constructor (explicit) should work");
				
				//	Check the copy CTOR (auto)
				auto list4 = list;
				t->assertTrue(checkIntegerListsEqual(list, list4), 1, "Copy constructor (auto) should work");
				
				//	Check comparison
				t->assertTrue(list == list2 && list2.size() > 0, 1, "Comparison operator check");
				t->assertFalse(list != list2 || list2.size() == 0, 1, "Inequality operator check");
				
				//	Make list3 different, then recheck comparisons
				list3.push_back(0);
				t->assertFalse(list == list3 || list3.size() == 0, 1, "Comparison operator check");
				t->assertTrue(list != list3 && list3.size() > 0, 1, "Inequality operator check");
				
				//	Make list4 different, then recheck comparisons
				list4.push_back(0);
				t->assertFalse(list == list4 || list4.size() == 0, 1, "Comparison operator check");
				t->assertTrue(list != list4 && list4.size() > 0, 1, "Inequality operator check");
			}
			
		}, 1, "List assignment tests"
	);
}

//
void testListAccordion(Tests& tests)
{
	//
	auto t = tests.createTest("Accordion");
	
	//
	t->setFixedPointsPossible(6);
	t->setNormalizedPointsPossibleTarget(10);
	
	//
	t->assertNoException(
		[t]()
		{
			//
			{
				//
				CPSC131::DoublyLinkedList::DoublyLinkedList<int> list;
				for ( int i = 0; i < 100; i++ ) {
					list.push_front(i * 2);
					list.push_back(i * 2);
				}
				t->assertEqual(list.size(), 200UL, 1, "Check size after a bunch of push_front and push_back");
				
				for ( int i = 0; i < 50; i++ ) {
					list.pop_front();
					list.pop_back();
				}
				t->assertEqual(list.size(), 100UL, 1, "Check size after some pop_front and pop_back");
				t->assertFalse(list.empty(), 1, "Check empty() after some pop_front and pop_back");
				
				for ( int i = 0; i < 50; i++ ) {
					list.pop_front();
					list.pop_back();
				}
				t->assertEqual(list.size(), 0UL, 1, "Check size after depleting with pop_front and pop_back");
				t->assertTrue(list.empty(), 1, "Check empty() after depleting with pop_front and pop_back");
			}
			
		}, 1, "Accordion tests"
	);
}

//
void testListReverse(Tests& tests)
{
	//
	auto t = tests.createTest("List reverse");
	
	//
	t->setFixedPointsPossible(3);
	t->setNormalizedPointsPossibleTarget(5);
	
	//
	t->assertNoException(
		[t]()
		{
			{
				auto list1 = makeList();
				auto list2 = list1;
				
				list2.clear();
				list2.push_back(27);
				list2.push_back(24);
				list2.push_back(21);
				list2.push_back(18);
				list2.push_back(15);
				list2.push_back(12);
				list2.push_back(9);
				list2.push_back(6);
				list2.push_back(3);
				list2.push_back(0);
				list2.push_back(-3);
				list2.push_back(-6);
				list2.push_back(-9);
				list2.push_back(-12);
				list2.push_back(-15);
				list2.push_back(-18);
				list2.push_back(-21);
				list2.push_back(-24);
				list2.push_back(-27);
				list2.push_back(-30);
				
				list1.reverse();
				
				t->assertTrue(
					list1.size() == 20 && list1 == list2, 2, "Correctly reverse a list"
				);
			}
		}, 1, "Reverse tests"
	);
}

//
void testIterators(Tests& tests)
{
	//
	auto t = tests.createTest("Iterators");
	
	//
	t->setFixedPointsPossible(24);
	t->setNormalizedPointsPossibleTarget(10);
	
	//	Prefix/postfix increment/decrement operators
	t->assertNoException(
		[t]()
		{
			{
				//
				auto list = makeList();
				auto itr = list.begin();
				
				for ( size_t i = 0; i < 8; i++ ) {
					itr++;
				}
				
				//	Prefix increment operator
				auto prefix_inc_result = ++itr;
				t->assertEqual(
					(*itr), static_cast<int>(-3),
					1, "Prefix iterator increment"
				);
				t->assertEqual(
					*prefix_inc_result, *itr,
					1, "Prefix iterator increment should return the new value"
				);
				
				//	Postfix increment operator
				itr++;
				itr++;
				auto postfix_inc_result = itr++;
				t->assertEqual(
					(*itr), static_cast<int>(6),
					1, "Postfix iterator increment"
				);
				t->assertEqual(
					(*postfix_inc_result), 3,
					1, "Postfix iterator increment should return the old value"
				);
				
				//	Prefix decrement operators
				--itr;
				--itr;
				auto prefix_dec_result = --itr;
				t->assertEqual(
					(*itr), static_cast<int>(-3),
					1, "Prefix iterator decrement"
				);
				t->assertEqual(
					*prefix_dec_result, *itr,
					1, "Prefix iterator decrement should return the new value"
				);
				
				//	Postfix decrement operator
				itr--;
				auto postfix_dec_result = itr--;
				t->assertEqual(
					(*itr), static_cast<int>(-9),
					1, "Postfix iterator decrement"
				);
				t->assertEqual(
					(*postfix_dec_result), static_cast<int>(-6),
					1, "Postfix iterator decrement should return the old value"
				);
			}
			
		}, 1, "Iterator post/prefix increment/decrement operators"
	);
	
	//	Addition/Subtraction operators
	t->assertNoException(
		[t]()
		{
			{
				//
				auto list = makeList();
				auto itr = list.begin();
				size_t half = list.size() / 2;
				
				//
				t->assertEqual(
					(*(itr + half)), static_cast<int>(0),
					1, "Addition operator"
				);
				
				t->assertEqual(
					(*((itr + half) - 3)), static_cast<int>(-9),
					1, "Subtraction operator"
				);
			}
			
		}, 1, "Iterator addition/subtraction operators"
	);
	
	//	Addition/Subtraction/Assignment operators
	t->assertNoException(
		[t]()
		{
			{
				//
				auto list = makeList();
				auto itr1 = list.begin();
				auto itr2 = list.begin();
				size_t half = list.size() / 2;
				
				//	Addition assignment
				itr1 += half;
				itr1 += 1;
				t->assertEqual(
					(*itr1), static_cast<int>(3),
					1, "Iterator addition assignment"
				);
				
				//	Try to get the cursor out-of-bounds
				itr1 += 5000;
				t->assertTrue(
					itr1 == list.end(),
					1, "Depleted iterator should become end()"
				);
				
				//	Subtraction assignment
				itr2 += half;
				itr2 -= 2;
				t->assertEqual(
					(*itr2), static_cast<int>(-6),
					1, "Iterator subtraction assignment"
				);
			}
			
		}, 1, "Iterator addition/subtraction operator"
	);
	
	//	Assignment Operator, copy CTOR, comparison Operators
	t->assertNoException(
		[t]()
		{
			{
				//
				auto list = makeList();
				size_t half = list.size() / 2;
				
				auto itr1 = list.begin();
				itr1 += half;
				
				//	Comparison
				{
					auto itr2 = list.begin();
					itr2 += half;
					t->assertTrue(
						itr1 == itr2,
						1, "Iterator comparison operator"
					);
					itr1 -= 5;
					t->assertFalse(
						itr1 == itr2,
						1, "Iterator comparison operator"
					);
					//	Inequality
					t->assertTrue(
						itr1 != itr2,
						1, "Iterator inequality operator"
					);
				}
				
				//	Assignment operator
				{
					auto itr2 = list.begin();
					itr2 = itr1;
					t->assertTrue(
						itr1 == itr2,
						1, "Iterator assignment operator"
					);
				}
				
				//	Copy CTOR
				{
					auto itr2 = itr1;
					t->assertTrue(
						itr1 == itr2,
						1, "Iterator copy CTOR"
					);
				}
				
				//	Copy CTOR with addition
				{
					auto itr2 = itr1 + 3;
					t->assertEqual(
						*itr2, static_cast<int>(-6),
						1, "Iterator copy CTOR with addition operator"
					);
				}
				
				//	Copy CTOR with subtraction
				{
					auto itr2 = itr1 - 4;
					t->assertEqual(
						*itr2, static_cast<int>(-27),
						1, "Iterator copy CTOR with subtraction operator"
					);
				}
			}
			
		}, 1, "Iterator assignment Operator, copy CTOR, comparison Operators"
	);
}


//
void testInsertPush(Tests& tests)
{
	//
	auto t = tests.createTest("Insert/Push");
	
	//
	t->setFixedPointsPossible(19);
	t->setNormalizedPointsPossibleTarget(5);
	
	//	insert_after(itr)
	t->assertNoException(
		[t]()
		{
			{
				//	Setup list and iterators
				auto list = makeList();
				auto itr_middle = list.begin() + list.size() / 2;
				auto itr_begin = list.begin();
				auto itr_end = list.end();
				
				// Insert after (middle)
				auto itr_middle_result = list.insert_after(itr_middle, 18763);
				t->assertEqual(
					(*(itr_middle + 1)), static_cast<int>(18763),
					1, "insert_after(itr, middle): Checking value after old iterator position"
				);
				t->assertEqual(
					*itr_middle_result, static_cast<int>(18763),
					1, "insert_after(itr, middle): Checking value at result iterator position"
				);
				
				// Insert after (begin)
				auto itr_begin_result = list.insert_after(itr_begin, 37544);
				t->assertEqual(
					(*(itr_begin + 1)), static_cast<int>(37544),
					1, "insert_after(itr, begin): Checking value after old iterator position"
				);
				t->assertEqual(
					*itr_begin_result, static_cast<int>(37544),
					1, "insert_after(itr, begin): Checking value at result iterator position"
				);
				
				// Insert after (end)
				auto itr_end_result = list.insert_after(itr_end, 227444);
				t->assertEqual(
					list.at( list.size() - 1 ), static_cast<int>(227444),
					1, "insert_after(itr, end): Checking new last value"
				);
				t->assertEqual(
					*itr_end_result, static_cast<int>(227444),
					1, "insert_after(itr, end): Checking value at result iterator position"
				);
			}
			
		},1, "insert_after(itr)"
	);
	
	//	insert_after(idx)
	t->assertNoException(
		[t]()
		{
			{
				//	Test both insert_after methods and push_after at the same time
				auto list = makeList();
				size_t idx = list.size() / 2;
				
				// Insert after (middle)
				list.insert_after(idx, 88227184);
				t->assertEqual(
					list.at(idx + 1), static_cast<int>(88227184),
					1, "insert_after(idx): Checking value after original position"
				);
				
				// Insert after (begin)
				list.insert_after(0, 123111);
				t->assertEqual(
					list.at(1), static_cast<int>(123111),
					1, "insert_after(begin): Checking value after beginning"
				);
				
				// Insert after (end)
				list.insert_after(list.size() - 1, 2233554);
				t->assertEqual(
					list.at( list.size() - 1 ), static_cast<int>(2233554),
					1, "insert_after(end): Checking new last value"
				);
				
				// Insert after (way beyond end)
				list.insert_after(list.size() + 100, 22883445);
				t->assertEqual(
					list.at( list.size() - 1 ), static_cast<int>(22883445),
					1, "insert_after(way beyond end): Checking new last value"
				);
			}
			
		},1, "insert_after(idx)"
	);
	
	//	push_after(itr)
	t->assertNoException(
		[t]()
		{
			{
				//	Setup list and iterators
				auto list = makeList();
				auto itr_middle = list.begin() + list.size() / 2;
				auto itr_begin = list.begin();
				auto itr_end = list.end();
				
				// Push after (middle)
				auto itr_middle_result = list.push_after(itr_middle, 2716173);
				t->assertEqual(
					(*(itr_middle + 1)), static_cast<int>(2716173),
					1, "push_after(itr, middle): Checking value after old iterator position"
				);
				t->assertEqual(
					*itr_middle_result, static_cast<int>(2716173),
					1, "push_after(itr, middle): Checking value at result iterator position"
				);
				
				// Push after (begin)
				auto itr_begin_result = list.push_after(itr_begin, 1199388);
				t->assertEqual(
					(*(itr_begin + 1)), static_cast<int>(1199388),
					1, "push_after(itr, begin): Checking value after old iterator position"
				);
				t->assertEqual(
					*itr_begin_result, static_cast<int>(1199388),
					1, "push_after(itr, begin): Checking value at result iterator position"
				);
				
				// Push after (end)
				auto itr_end_result = list.push_after(itr_end, 99118822);
				t->assertEqual(
					list.at( list.size() - 1 ), static_cast<int>(99118822),
					1, "push_after(itr, end): Checking new last value"
				);
				t->assertEqual(
					*itr_end_result, static_cast<int>(99118822),
					1, "push_after(itr, end): Checking value at result iterator position"
				);
			}
			
		},1, "push_after(itr)"
	);
}


//
void testErase(Tests& tests)
{
	//
	auto t = tests.createTest("Erase");
	
	//
	t->setFixedPointsPossible(3);
	t->setNormalizedPointsPossibleTarget(5);
	
	//	erase
	t->assertNoException(
		[t]()
		{
			//
			auto list = makeList();
			auto itr = list.begin();
			
			list.erase(itr);
			
			itr = list.begin();
			itr += 3;
			list.erase(itr);
			
			itr = list.begin();
			itr += 8;
			list.erase(itr);
			
			itr = list.begin();
			itr += 10;
			list.erase(itr);
			
			t->assertEqual(
				list.size(), 16ULL,
				1, "Check list has correct size after erase"
			);
			
			auto itr_check = list.begin();
			for ( int value : {-27, -24, -21, -15, -12, -9, -6, -3, 3, 6, 12, 15, 18, 21, 24, 27} ) {
				if ( *itr_check != value ) {
					t->assertEqual(
						*itr_check, value,
						1, "Check list item after erase()"
					);
				}
				itr_check++;
			}
			t->assertTrue(true, 1, "List items seem to be correct after multiple calls to erase");
			
		}, 1, "erase"
	);
}


//
void testAssign(Tests& tests)
{
	//
	auto t = tests.createTest("Assign");
	
	//
	t->setFixedPointsPossible(12);
	t->setNormalizedPointsPossibleTarget(5);
	
	//	assign(count, value)
	t->assertNoException(
		[t]()
		{
			//
			CPSC131::DoublyLinkedList::DoublyLinkedList<int> list;
			
			list.assign(337, 12848);
			t->assertEqual(
				list.size(), 337ULL,
				1, "Check list has correct size after assign(count, value)"
			);
			
			for ( auto value : list ) {
				if ( value != 12848 ) {
					t->assertEqual(
						value, 12848,
						1, "All values after assign(count, value) should be correct"
					);
				}
			}
			t->assertTrue(
				true,
				1, "All values after assign(count, value) are correct"
			);
			
		}, 1, "assign(count, value)"
	);
	
	//	assign(itr, itr)
	t->assertNoException(
		[t]()
		{
			//
			auto list1 = makeList();
			CPSC131::DoublyLinkedList::DoublyLinkedList<int> list2;
			
			auto itr1 = list1.begin() + 5;	//	advance from index 0 to index 5
			auto itr2 = itr1 + 13;			//	itr2 should be sitting at 5 + 13 == 18
			
			//	itr1 => at index 5
			//	itr2 => at index 18
			//	Inclusive copy from itr1 to itr2 should give us size == 14 (aka 18-5+1)
			list2.assign(itr1, itr2);
			
			t->assertEqual(list2.size(), 14ULL, 1, "Check size after assign(itr, itr)");
			
			auto itr_a = itr1;
			for ( auto itr_b = list2.begin(); itr_b != list2.end(); itr_a++, itr_b++ ) {
				if ( *itr_a != *itr_b ) {
					t->assertEqual
					(
						*itr_a, *itr_b,
						1, "Checking correct list items after assign(itr, itr)"
					);
				}
			}
			t->assertTrue
			(
				true,
				1, "Done checking correct list items after assign(itr, itr)"
			);
			
		}, 1, "assign(itr, itr)"
	);
	
	//	assign(itr, itr) with backward iterators
	t->assertNoException(
		[t]()
		{
			//
			auto list1 = makeList();
			CPSC131::DoublyLinkedList::DoublyLinkedList<int> list2;
			
			auto itr1 = list1.begin() + 5;
			auto itr2 = itr1 + 13;
			list2.assign(itr2, itr1);	// yeah whoops
			
			t->assertEqual(list2.size(), 2ULL, 1, "Check size after assign(itr, itr)");
			
			t->assertTrue
			(
				checkIntegerListContents(list2, {24, 27}), 1,
				"Checking list items after assign with backwards iterators"
			);
			
		}, 1, "assign(itr, itr) with backwards iterators"
	);
	
	//	assign(itr, itr) with first iterator already at end
	t->assertNoException(
		[t]()
		{
			//
			auto list1 = makeList();
			CPSC131::DoublyLinkedList::DoublyLinkedList<int> list2;
			
			auto itr1 = list1.begin() + 5000000;	// lol no
			auto itr2 = itr1 + 100;
			list2.assign(itr1, itr2);
			
			t->assertEqual(list2.size(), 0ULL, 1, "Check size after assign(itr, itr)");
			
			t->assertTrue
			(
				checkIntegerListContents(list2, {}), 1,
				"Checking list items after assign with first iterator already at end (should be empty)"
			);
			
		}, 1, "assign(itr, itr) with first iterator already at end"
	);
}

//
void testPointerStealing(Tests& tests)
{
	//
	auto t = tests.createTest("Pointer Stealing");
	
	//
	t->setFixedPointsPossible(2);
	t->setNormalizedPointsPossibleTarget(10);
	
	//
	t->assertNoException(
		[t]()
		{
			//
			auto list1 = makeList();
			
			CPSC131::DoublyLinkedList::DoublyLinkedList<int> list2;
			list2 = list1;
			
			auto list3 = list1;
			
			CPSC131::DoublyLinkedList::DoublyLinkedList<int> list4;
			list4.assign(list1.begin(), list1.end());
			
			t->assertTrue
			(
				checkIntegerListsEqual(list1, list2),
				0, "Verifying equality before pointer-steal check"
			);
			t->assertTrue
			(
				checkIntegerListsEqual(list1, list3),
				0, "Verifying equality before pointer-steal check"
			);
			t->assertTrue
			(
				checkIntegerListsEqual(list1, list4),
				0, "Verifying equality before pointer-steal check"
			);
			
			auto itr = list1.begin();
			itr += 8;
			(*itr)++;
			
			t->assertTrue
			(
				checkIntegerListsEqual(list2, list3),
				0, "Verifying equality after pointer-steal check"
			);
			t->assertTrue
			(
				checkIntegerListsEqual(list3, list4),
				0, "Verifying equality after pointer-steal check"
			);
			t->assertFalse
			(
				checkIntegerListsEqual(list1, list2),
				0, "Verifying inequality after pointer-steal check"
			);
			
			t->assertTrue(true, 1, "Pointer stealing check seems to have passed.");
			
		}, 1, "pointer stealing checks"
	);
}

//
void testStockSales(Tests& tests)
{
	//
	auto t = tests.createTest("Stock/Sales");
	
	//
	t->setFixedPointsPossible(17);
	t->setNormalizedPointsPossibleTarget(14);
	
	//
	t->assertNoException(
		[t]()
		{
			//
			{
				//
				auto store = makeBookStore();
				
				//	Check initial balance
				//	(50×900)+(49×550)+(48×1200)+(47×2000)+(46×100) == -228150
				t->assertEqual(
					store.getAccountBalance(), static_cast<int>(-228150),
					1, "Correct balance after adding initial books"
				);
				
				//	Add additional book to check balance
				//	-228150 - (999*3) == -231147
				store.purchaseInventory(Book("Ninja Mind Control", "Ashida Kim", "1435769244", 999, 3));
				t->assertEqual(
					store.getAccountBalance(), static_cast<int>(-231147),
					1, "Correct balance after adding new book"
				);
				
				//	Check stock on the new book
				t->assertEqual(
					store.getBookStockAvailable("1435769244"), static_cast<size_t>(3),
					1, "Correct stock on newly added book"
				);

				//	Add more of an existing book to check balance
				//	-231147 - (1000*2) == -233147
				store.purchaseInventory(Book("Bla", "Bla", "1435769244", 1000, 2));
				t->assertEqual(
					store.getAccountBalance(), static_cast<int>(-233147),
					1, "Correct balance after adding more of an existing book at a different price"
				);
				t->assertEqual(
					store.getBookStockAvailable("1435769244"), static_cast<size_t>(5),
					1, "Correct stock after adding 2 more"
				);
				
				//	Add a book based on title, author, isbn, price cents,
				//	and unit count
				store.purchaseInventory("Super cool book", "Batman", "1438419254", 2000, 9);
				t->assertEqual(
					store.getAccountBalance(), static_cast<int>(-251147),
					1, "Correct balance after adding a book based on title, author, isbn, price cents, and unit count"
				);
				t->assertEqual(
					store.getBookStockAvailable("1438419254"), static_cast<size_t>(9),
					1, "Correct stock after adding a new book based on title, author, isbn, price cents, and unit count"
				);
				
				//	Add another same book based on title, author, isbn,
				//	price cents, and unit count
				//	-251147 - (2000 * 2) == -255147
				store.purchaseInventory("Super cool book", "Batman", "1438419254", 2000, 2);
				t->assertEqual(
					store.getAccountBalance(), static_cast<int>(-255147),
					1, "Correct balance after adding more of an existing book at a different price"
				);
				t->assertEqual(
					store.getBookStockAvailable("1438419254"), static_cast<size_t>(11),
					1, "Correct stock after adding 2 more"
				);

				//	Increase funds after customer purchases one book
				store.sellToCustomer("1435769244", 2000, 3);
				t->assertEqual(
					store.getAccountBalance(), static_cast<int>(-249147),
					1, "Correct balance after selling some books"
				);
			}
			
			{
				//	Starts with balance -228150
				auto store = makeBookStore();
				
				//	Adjust balance
				store.adjustAccountBalance(12983);
				t->assertEqual(
					store.getAccountBalance(), static_cast<int>(-215167),
					1, "Adjust account balance"
				);
				store.adjustAccountBalance(-228);
				t->assertEqual(
					store.getAccountBalance(), static_cast<int>(-215395),
					1, "Adjust account balance"
				);
				
				//	Check inventory
				t->assertTrue(
					store.bookExists("0533112923"), 1, "Calling bookExists() on existing book"
				);
				t->assertFalse(
					store.bookExists("053zzz3112923"), 1, "Calling bookExists() on non-existing book"
				);
			}
			
		}, 2, "Account balance tests"
	);
	
	//	Separate test to check overselling so we don't run into the "dead local reference".
	//	that happens when trying to nest tests too deeply.
	//	We should see an exception if we try to oversell a book.
	t->assertException(
		[t]()
		{
			//
			auto store = makeBookStore();
			
			//	Purchase some inventory to avoid default values
			store.purchaseInventory(Book("Ninja Mind Control", "Ashida Kim", "1435769244", 999, 3));
			store.purchaseInventory(Book("Bla", "Bla", "1435769244", 1000, 2));
			
			//store.printInventory();
			store.sellToCustomer("1435769244", 2000, 6);
		}, 1, "Should see an exception if we try to oversell a book."
	);
	
}

//
void testMemoryLeaks(Tests& tests)
{
	//
	auto t = tests.createTest("Memory Leaks");
	
	//
	t->setFixedPointsPossible(11);
	t->setNormalizedPointsPossibleTarget(5);
	
	//
	t->assertNoException(
		[t]()
		{
			//
			string stdout, stderr, message;
			bool leakCheckResult = PuhPTests::Memory::checkMemoryLeaks
			(
				{"make", "leak-checker"},
				"leak-checker",
				stdout, stderr, message
			);
			
			//
			if ( !leakCheckResult ) {
				t->log("Leak Check Result :: STDOUT\n" + stdout);
				t->log("Leak Check Result :: STDERR\n" + stderr);
			}
			t->assertTrue(leakCheckResult, 10, "Checking for memory leaks: " + message);
			
		}, 1, "Memory leaks"
	);
}



